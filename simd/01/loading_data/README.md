
## SIMD 데이터 로딩과 저장

### 1. 정렬된 vs 정렬되지 않은 메모리

- 메모리 정렬이란
    ```
    정렬된 주소 (32바이트 정렬):
    0x0000  ✓ 32의 배수
    0x0020  ✓
    x0040  ✓

    정렬 안 된 주소:
    0x0001  ✗ 32의 배수 아님
    0x0023  ✗
    ```
- CPU가 메모리를 읽는 방식
    정렬된 로드
    ```
    메모리 주소 0x1000 (32바이트 정렬)
    ┌────────────────────────────────┐
    │   32바이트를 한 번에 읽기      │
    └────────────────────────────────┘
    CPU 메모리 버스와 정확히 일치 → 1번 읽기
    ```
    정렬 안 된 로드
    ```
    메모리 주소 0x1004 (정렬 안 됨)
        ┌────────────────────────────────┐
        │   경계를 넘어감                │
        └────────────────────────────────┘
    ┌─────────────┐         ┌──────────────┐
    │  1번째 읽기 │         │  2번째 읽기  │
    └─────────────┘         └──────────────┘
             ↓                      ↓
        [결과 조합] → 느림
    ```

### 2. 마스크 로드/저장

- 마스크의 작동 원리
    ```
    __m256i mask = _mm256_set_epi32(0, -1, 0, -1, 0, -1, 0, -1);
    ```
- 비트 레벨
    ```
    -1 = 0xFFFFFFFF (모든 비트 1) → 로드/저장
     0 = 0x00000000 (모든 비트 0) → 무시

    마스크:  [  0  ][-1 ][ 0 ][-1 ][ 0 ][-1 ][ 0 ][-1 ]
    인덱스:    7     6     5    4     3    2     1    0
    ```
- 마스크 로드
    ```
    메모리:    [1] [2] [3] [4] [5] [6] [7] [8]
    마스크:     0  -1   0  -1   0  -1   0  -1
               ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
    결과:      [0] [2] [0] [4] [0] [6] [0] [8]
    ```

사용 예

```cpp
float data[11];  // 11개 요소

// 처음 8개는 일반 SIMD로 처리
_mm256_store_ps(&data[0], vec1);

// 마지막 3개 처리
__m256 last_vec = /* 마지막 데이터 */;
__m256i mask = _mm256_set_epi32(0, 0, 0, 0, 0, -1, -1, -1);
//                              [7][6][5][4][3][2][1][0]
//                               ✗  ✗  ✗  ✗  ✗  ✓  ✓  ✓

_mm256_maskstore_ps(&data[8], mask, last_vec);
// data[8]부터 8개 위치를 시도하지만
// 마스크 때문에 실제로는 data[8], data[9], data[10]만 저장
// data[11], [12], [13], [14], [15]는 저장 안 함 (범위 밖)
```

실제 동작

```
메모리 위치:  [8]  [9]  [10] [11] [12] [13] [14] [15]
마스크:       -1   -1   -1    0    0    0    0    0
             ✓    ✓    ✓    ✗    ✗    ✗    ✗    ✗
결과:        저장  저장  저장  무시  무시  무시  무시  무시
```

사용예시

```cpp
void process_array(float* data, int size) {
    int i = 0;

    // 8개씩 처리
    for (; i + 8 <= size; i += 8) {
        __m256 vec = _mm256_load_ps(&data[i]);
        // 처리...
        _mm256_store_ps(&data[i], result);
    }

    // 남은 요소 처리 (8개 미만)
    if (i < size) {
        int remaining = size - i;

        // 남은 개수만큼 마스크 생성
        int mask_values[8] = {0};
        for (int j = 0; j < remaining; j++) {
            mask_values[j] = -1;
        }

        __m256i mask = _mm256_set_epi32(
            mask_values[7], mask_values[6],
            mask_values[5], mask_values[4],
            mask_values[3], mask_values[2],
            mask_values[1], mask_values[0]
        );

        __m256 vec = _mm256_maskload_ps(&data[i], mask);
        // 처리...
        _mm256_maskstore_ps(&data[i], mask, result);
    }
}
```

### 3. 스트림 연산 (Non-temporal)

CPU 캐시 계층 구조

```
CPU
 ├─ L1 캐시 (32KB, 매우 빠름)
 ├─ L2 캐시 (256KB, 빠름)
 ├─ L3 캐시 (8MB, 보통)
 └─ RAM (16GB, 느림)
```

일반 로드/저장

```
일반 저장:
CPU → L1 캐시 → L2 캐시 → L3 캐시 → RAM
         ↓
    캐시에 복사본 유지 (다음에 빠르게 접근 가능)
```

문제: 대용량 데이터를 한 번만 처리할 때

```
1GB 데이터 처리 → 8MB 캐시를 모두 차지
→ 다른 중요한 데이터가 캐시에서 밀려남 (캐시 오염)
```

스트림 저장

```
스트림 저장:
CPU → RAM (캐시 우회)
       ↓
   캐시를 건드리지 않음
```

다음 경우에 사용
- 대용량 파일 읽기/쓰기
- 비디오 프레임 처리 (한 번만 사용)
- 대용량 배열 초기화

코드 예시

```cpp
// 1GB 배열 초기화
for (int i = 0; i < size; i += 8) {
    __m256 zero = _mm256_setzero_ps();
    _mm256_stream_ps(&array[i], zero);  // 캐시 우회
}
_mm_sfence();  // 모든 쓰기 완료 대기
```

_mm_sfence()의 역할

스트림 저장은 비동기적으로 실행

```
CPU: "저장해!" → 계속 다음 코드 실행
                  ↓
            백그라운드에서 저장 중...

_mm_sfence(): "모든 저장이 완료될 때까지 기다려!"
```

성능 비교 요약

```
연산 타입              속도        사용 시기
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
정렬된 로드/저장      매우 빠름    항상 (가능하면)
정렬 안 된 로드/저장  약간 느림    정렬 불가능할 때
마스크 로드/저장      중간         일부 요소만 처리
스트림 로드/저장      빠름         대용량 1회 처리
```

시나리오

- 시나리오 1: 이미지 처리 (재사용)
    ```cpp
    // 이미지를 여러 번 처리 → 일반 로드/저장 (캐시 활용)
    for (int pass = 0; pass < 10; pass++) {
        for (int i = 0; i < size; i += 8) {
            __m256 pixel = _mm256_load_ps(&image[i]);
            // 처리...
            _mm256_store_ps(&image[i], result);
        }
    }
    ```

- 시나리오 2: 비디오 인코딩 (1회만)
    ```cpp
    // 프레임을 한 번만 처리 → 스트림 저장 (캐시 오염 방지)
    for (int i = 0; i < frame_size; i += 8) {
        __m256 frame = _mm256_loadu_ps(&input[i]);
        __m256 encoded = encode(frame);
        _mm256_stream_ps(&output[i], encoded);  // 캐시 우회
    }
    _mm_sfence();
    ```

- 시나리오 3: 배열 끝 처리
    ```cpp
    // 크기가 8의 배수가 아닐 때 → 마스크 사용
    int size = 27;  // 8*3 + 3
    for (int i = 0; i < 24; i += 8) {
        // 일반 SIMD
    }gg
    // 마지막 3개는 마스크로
    __m256i mask = _mm256_set_epi32(0,0,0,0,0,-1,-1,-1);
    _mm256_maskstore_ps(&array[24], mask, last_vec);
    ```
