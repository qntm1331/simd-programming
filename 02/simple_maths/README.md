
## SIMD의 8가지 수학 연산

수평 연산이 느린 이유는 데이터를 재배치해야 하기 때문

가능하면 수직 연산을 사용하는 게 좋다.

### 1-4. 기본 산술 연산 (수직 연산)

덧셈, 뺄셈, 곱셈, 나눗셈 모두 동일한 패턴

```cpp
__m256 result = _mm256_add_ps(vector1, vector2);
```

수직 연산

```
vector1: [1, 2, 3, 4, 5, 6, 7, 8]
vector2: [8, 7, 6, 5, 4, 3, 2, 1]
         ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  (같은 위치끼리)
결과:    [9, 9, 9, 9, 9, 9, 9, 9]
```

### 5. FMA (Fused Multiply-Add)

```cpp
__m256 result = _mm256_fmadd_ps(vector1, vector2, vector3);
// result = vector1 * vector2 + vector3
```

일반 방식 vs FMA

```
일반:
1. temp = vector1 * vector2  (곱셈)
2. result = temp + vector3   (덧셈)

FMA:
1. result = vector1 * vector2 + vector3  (한 번에)
```

정확도 차이

```
// 일반 방식
float a = 1e20f, b = 1e-20f, c = 1.0f;
float temp = a * b;  // 1.0 (반올림 발생)
float result = temp + c;  // 2.0

// FMA 방식
// 내부에서 더 높은 정밀도로 계산
// 최종 결과만 반올림 → 더 정확
```

### 6. 제곱근

```cpp
__m256 sqrt_result = _mm256_sqrt_ps(pos_vector);
```

8개의 제곱근을 동시에 계산

```
입력:  [1,  4,  9, 16, 25, 36, 49, 64]
결과:  [1,  2,  3,  4,  5,  6,  7,  8]
```

### 7. 최소/최대

```cpp
__m256 min = _mm256_min_ps(v1, v2);
__m256 max = _mm256_max_ps(v1, v2);
```

요소별 비교

```
v1:  [1, 2, 3, 4, 5, 6, 7, 8]
v2:  [8, 7, 6, 5, 4, 3, 2, 1]
     ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
min: [1, 2, 3, 4, 4, 3, 2, 1]
max: [8, 7, 6, 5, 5, 6, 7, 8]
```

### 8. 수평 연산 (특이함!)

일반 연산 (수직)

```
v1: [1, 2, 3, 4, 5, 6, 7, 8]
v2: [9,10,11,12,13,14,15,16]
    ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  (같은 인덱스끼리)
```

수평 덧셈 (hadd)

```
v1: [1, 2, 3, 4 | 5, 6, 7, 8]
     └┬┘ └┬┘      └┬┘ └┬┘
      3   7        11  15

v2: [9,10,11,12 |13,14,15,16]
     └┬┘ └┬┘      └┬┘ └┬┘
     19  23       27  31

결과 = _mm256_hadd_ps(v1, v2):
[3, 7, 19, 23 | 11, 15, 27, 31]
 ↑  ↑   ↑   ↑    ↑   ↑   ↑   ↑
v1의 v1의 v2의 v2의 v1의 v1의 v2의 v2의
인접 인접 인접 인접 인접 인접 인접 인접
```

- 하위 128비트: v1[0]+v1[1], v1[2]+v1[3], v2[0]+v2[1], v2[2]+v2[3]
- 상위 128비트: v1[4]+v1[5], v1[6]+v1[7], v2[4]+v2[5], v2[6]+v2[7]

```cpp
// 내적(dot product) 계산
__m256 prod = _mm256_mul_ps(a, b);  // [a0*b0, a1*b1, ...]
__m256 sum1 = _mm256_hadd_ps(prod, prod);
__m256 sum2 = _mm256_hadd_ps(sum1, sum1);
// 최종적으로 모든 요소의 합을 구함
```

---

### 성능 특성

```
연산         상대 속도
덧셈/뺄셈    매우 빠름 (1 사이클)
곱셈         빠름 (3-5 사이클)
나눗셈       느림 (10-20 사이클)
FMA          곱셈과 비슷 (3-5 사이클)
제곱근       중간 (10-15 사이클)
min/max      매우 빠름 (1-2 사이클)
hadd/hsub    느림 (5-10 사이클) - 데이터 재배치 필요
```
